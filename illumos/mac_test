#!/usr/bin/ksh
#
# Test MAC, aggr, and various drivers indirectly from user space.
#
# TODO
# * test rxrings=hw when the VNIC shares an addr with another client
#
# NOTES
#
#    For most of these tests you'll see the interface/addr variables
#    called send/send_ip and recv/recv_ip. These represent the
#    "primary" interface of the device; they are the "primary"
#    interface because they are named directly after the device. E.g.,
#    ixgbe0 is a primary interface because it's the same name as the
#    device. These primary interfaces are involved in almost every
#    test because they are typically always present in a production
#    deployment (or at least they are in the case of SmartOS, which
#    these tests were originally developer for). One thing we always
#    want to be sure of is that no matter what changes are made to the
#    system the primary interface should always be able to send and
#    receive traffic. Thus, while it might be a bit redundant, we
#    verify this ability as part of most tests to be absolutely sure
#    that none of the various scenarios have a bad effect on the
#    primary interface.
#
set -u				# catch unset variables

#
# Stolen from Mike Gerdts. Thanks Mike!
#
# https://mgerdts.github.io/2011/01/03/ksh93-stack-traces.html
#
function backtrace {
        typeset -a stack
        # Use "set -u" and an undefined variable access in a subshell
        # to figure out how we got here.  Each token of the result is
        # stored as an element in an indexed array named "stack".
        set -A stack $(exec 2>&1; set -u; unset __unset__; echo $__unset__)

        # Trim the last entries in stack array until we find the one that
        # matches the name of this function.
        typeset i=0
        for (( i = ${#stack[@]} - 1; i >= 0; i-- )); do
                [[ "${stack[i]}" == "${.sh.fun}:" ]] && break
        done

        # Print the name of the function that called this one, stripping off
        # the [lineno] and appending any arguments provided to this function.
        print -u2 "${stack[i-1]/\[[0-9]*\]} $*"
        # Print the backtrace.
        for (( i--; i >= 0; i-- )); do
                print -u2 "\t${stack[i]%:}"
        done
}

function fail
{
	typeset msg="$*"
	echo "FAIL [$TNAME]: $msg" >&2
	backtrace
	exit 1
}

function pass
{
	echo "PASS [$TNAME]"
}

function skip
{
	typeset msg="$*"
	echo "SKIP [$TNAME]: $msg"
}

function link_up
{
	typeset name=$1

	if dladm show-link -po state $name | grep up > /dev/null; then
		return 0
	else
		return 1
	fi
}

function vnic_over
{
	typeset link=$1

	if dladm show-vnic -po over | grep $link > /dev/null; then
		return 0
	else
		return 1
	fi
}

function nic_avail
{
	typeset nic=$1

	link_up $nic
	if [[ $? -ne 0 ]]; then
		return 1
	else
		dladm show-link | grep aggr | grep $nic > /dev/null
		if [[ $? -eq 0 ]]; then
			return 1
		fi
		return 0
	fi
}

function get_macaddr
{
	typeset vnic=$1

	dladm show-vnic -po macaddress $vnic
	if [[ $? -ne 0 ]]; then
		fail "could not get MAC address of VNIC $vnic"
	fi
}

function get_num_groups
{
	typeset nic=$1

	dladm show-phys -po ringtype -H $nic | grep RX | wc -l
}

#
# Get the number of available L2 unicast filters from an ixgbe
# instance.
#
function get_ixgbe_num_l2_filt
{
	typeset nic=$1

	typeset cmdstr="::walk mac_impl_cache |\
	    ::printf \"0x%p %s 0x%p\n\" mac_impl_t . mi_name mi_driver"
	typeset scratch=$(mdb -k -e "$cmdstr" | awk "/$nic/ { print \$3 }")
	typeset cmdstr="${scratch}::print ixgbe_t unicst_avail |=D"
	integer num_l2_filt=$(pfexec mdb -k -e "$cmdstr")
	echo $num_l2_filt
}

function get_num_l2_filt
{
	typeset nic=$1

	case $nic in
	ixgbe*)
		get_ixgbe_num_l2_filt $nic
		;;
	*)
		fail "cannot query unknown nic type: $nic"
		;;
	esac
}

function create_aggr
{
	typeset name=$1
	typeset port1=$2
	typeset port2=$3

	if ! dladm create-aggr -t -P L2,L3,L4 -L active -T short \
	     -l $port1 -l $port2 $name; then
		fail "failed to create aggr $aggr: [$port1, $port2]"
	fi
}

function delete_aggr
{
	typeset name=$1

	if ! dladm delete-aggr $name; then
		fail "failed to delete aggr $aggr"
	fi
}

function create_vnic
{
	typeset addr_str=""
	typeset prop_str=""
	typeset vid_str=""

	while getopts ":hm:sv:" opt
	do
		case $opt in
		h)
			prop_str="-p rxrings=hw"
			;;
		m)
			addr_str="-m $OPTARG"
			;;
		s)
			prop_str="-p rxrings=sw"
			;;
		v)
			vid_str="-v $OPTARG"
			;;
		':')
			fail "missing argument to $OPTARG"
			;;
		'?')
			fail "unknown option $OPTARG"
			;;
		esac
	done
	shift $((OPTIND -1))

	typeset link=$1
	typeset vnic=$2

	dladm create-vnic -t -l $link $addr_str $vid_str $prop_str $vnic

	if [[ $? -ne 0 ]]; then
		fail "failed to create VNIC $vnic over $link"
	fi
}

function delete_vnic
{
	typeset vnic=$1

	dladm delete-vnic -t $vnic

	if [[ $? -ne 0 ]]; then
		fail "failed to delete VNIC $vnic"
	fi
}

function primary_up
{
	typeset nic=$1

	if ! ifconfig $nic up; then
		fail "failed to bring up interface $nic"
	fi
}

function primary_down
{
	typeset nic=$1

	if ! ifconfig $nic down; then
		fail "failed to bring down interface $nic"
	fi
}

function create_interface
{
	typeset interface=$1

	ipadm create-if -t $interface

	if [[ $? -ne 0 ]]; then
		fail "failed to create interface $interface"
	fi
}

function delete_interface
{
	typeset interface=$1

	ipadm delete-if $interface

	if [[ $? -ne 0 ]]; then
		fail "failed to delete interface $interface"
	fi
}

function create_addr
{
	typeset ip=$1
	typeset interface=$2

	ipadm create-addr -t -T static -a $ip/24 $interface/v4

	if [[ $? -ne 0 ]]; then
		fail "failed to plumb IP onto $interface"
	fi
}

function delete_addr
{
	typeset interface=$1

	ipadm delete-addr $interface/v4

	if [[ $? -ne 0 ]]; then
		fail "failed to delete addr $interface/v4"
	fi
}

function send_traffic
{
	typeset send_ip=$1
	typeset recv_ip=$2
	typeset recv_vnic=$3
	typeset recv_type=$4
	typeset src_file=/tmp/mt_src
	typeset dst_file=/tmp/mt_dst
	typeset digest_file=/tmp/mt_src_digest
	typeset port=7777

	ping -i $send_ip $recv_ip > /dev/null
	if [[ $? -ne 0 ]]; then
		fail "failed to ping $recv_ip from $send_ip"
	fi

	#
	# Create a 50M data file.
	#
	dd if=/dev/urandom of=$src_file bs=1024 count=50000 > /dev/null 2>&1
	digest -a sha1 $src_file > $digest_file

	rm -f $dst_file
	socat -u TCP4-LISTEN:$port,bind=[$recv_ip],reuseaddr create:$dst_file &
	listener_pid=$!

	#
	# Send some traffic to VNIC.
	#
 	typeset bytes_before=$(kstat -p $recv_vnic:::rbytes | \
				       egrep "$recv_type" | \
				       grep -v fanout | \
				       awk '{ sum += $2 } END { print sum }')
	if [[ -z "$bytes_before" ]]; then
		fail "failed to read bytes_before for $recv_vnic"
	fi

	socat -b 4096 STDIN \
	      TCP4:$recv_ip:$port,bind=[$send_ip],connect-timeout=5 < $src_file
	if (($? != 0)); then
		kill -s TERM $litener_pid
		fail "failed to run socat client"
	fi

	#
	# Verify hwlane counters with kstat.
	#
	typeset bytes_after=$(kstat -p $recv_vnic:::rbytes | \
				      egrep "$recv_type" | \
				      grep -v fanout | \
				      awk '{ sum += $2 } END { print sum }')
	if [[ -z "$bytes_after" ]]; then
		fail "failed to read bytes_after for $recv_vnic"
	fi

	typeset bytes_delta=$(($bytes_after - $bytes_before))
	typeset bytes_expected=$((1024 * 50000))
	if [[ $bytes_after -lt $bytes_before \
		      || $bytes_delta -lt $bytes_expected ]]; then
		fail "expected at least $bytes_expected bytes on $recv_vnic,"\
		     "saw $bytes_delta"
	fi
}

function verify_nic_type
{
	typeset nic=$1
	typeset type=$2

	if ! echo $nic | grep "$type" > /dev/null; then
		fail "$nic is not of type $type"
	fi
}

function verify_primary_client
{
	typeset nic=$1

	if ! dladm show-phys -po clients -H $nic | grep $nic > /dev/null; then
		fail "no primary client found on $nic"
	fi
}

function verify_num_groups
{
	typeset nic=$1
	typeset expected=$2

	integer num=$(get_num_groups $nic)
	if (($expected != $num)); then
		fail "$nic has unexpected number of groups: $expected != $num"
	fi
}

function verify_num_groups_gte
{
	typeset nic=$1
	typeset expected=$2

	integer num=$(get_num_groups $nic)
	if (($num < $expected)); then
		fail "$nic does not have enough groups: $num < $expected"
	fi
}

function verify_no_primary
{
	typeset nic=$1

	if dladm show-phys -po clients -H | grep $nic; then
		fail "${nic}'s primary interface is already up"
	fi
}

function verify_nic
{
	typeset nic=$1

	if ! nic_avail $nic; then
		fail "link $nic does not exist or is part of aggr"
	fi

	if vnic_over $nic; then
		fail "found existing VNICs over $nic"
	fi
}

function verify_aggr
{
	typeset aggr=$1

	if ! dladm show-link -po state $aggr | grep up > /dev/null; then
		fail "aggr $aggr does not exist or is down"
	fi

	if vnic_over $aggr; then
		failed "found existing VNICs over $aggr"
	fi
}

function verify_if
{
	typeset interface=$1

	if ! ipadm show-if $interface > /dev/null 2>&1; then
		fail "interface $interface does not exist"
	fi
}

function verify_no_ip
{
	typeset ip=$1

	if ipadm show-addr -po addr | grep $ip > /dev/null; then
		fail "ip $ip already exists"
	fi
}

#
# Verify that $vnic is has a reserved (read hardware) group on $link.
# We can't use this with aggr's because a) they aren't exposed via
# `dladm show-phys` and b) the aggr's pseudo groups don't show up
# under the port's `show-phys -H` (it might be nice to rectify this
# situation).
#
function verify_hw
{
	typeset link=$1
	typeset client=$2

	if ! dladm show-phys -po ringtype,clients -H $link | grep RX | \
			grep $client > /dev/null
	then
		fail "no group info found for $client on $link"
	fi

	if dladm show-phys -po ringtype,clients -H $link | \
			grep $client | grep RX | grep default > /dev/null
	then
		fail "client $client is not on reserved (HW) group on $link"
	fi
}

#
# The opposite of verify_hw().
#
function verify_sw
{
	typeset link=$1
	typeset client=$2

	if ! dladm show-phys -po ringtype,clients -H $link | grep RX | \
			grep $client > /dev/null
	then
		fail "no group info found for $client on $link"
	fi

	if ! dladm show-phys -po ringtype,clients -H $link | \
			grep $client | grep RX | grep default > /dev/null
	then
		fail "client $client is not on default (SW) group on $link"
	fi
}

function is_promisc
{
	typeset nic=$1
	typeset nic_type=$(echo $nic | sed -E 's/[0-9]+//g')
	typeset nic_inst=$(echo $nic | sed -E 's/[a-z]+//g')
	integer promisc=$(kstat -p $nic_type:$nic_inst::promisc | \
					 awk '{ print $2 }')

	if (($promisc == 1)); then
		return 0
	else
		return 1
	fi

}

#
# TESTS
#
function test_generic_create_vnic
{
	typeset nic=$1
	typeset vn=mt_vn1

	TNAME="test_generic_create_vnic<$nic>"

	verify_nic $nic
	create_vnic $nic $vn
	delete_vnic $vn
	pass
}

function test_generic_create_vlan
{
	typeset nic=$1
	typeset vn=mt_vn1

	TNAME="test_generic_create_vlan<$nic>"

	verify_nic $nic
	create_vnic -v 5 $nic $vn
	delete_vnic $vn
	pass
}

#
# Verify that a VNIC gets Rx hardware resources and that unicast TCP
# traffic is hardware classified.
#
function test_generic_vnic_hw_rx
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset send_vn1="mt_send1"
	typeset recv_vn1="mt_recv1"

	TNAME="test_generic_vnic_hw_rx<$recv>"

	verify_nic $send
	verify_nic $recv
	verify_num_groups_gte $recv 3
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic $send $send_vn1
	create_vnic $recv $recv_vn1
	create_addr $send_ip1 $send_vn1
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 hwlane

	delete_addr $send
	delete_addr $recv
	delete_interface $send_vn1
	delete_interface $recv_vn1
	delete_vnic $send_vn1
	delete_vnic $recv_vn1
	pass
}

#
# Verify that a tagged VNIC gets Rx hardware resources and that
# unicast TCP traffic is hardware classified.
#
function test_generic_vlan_hw_rx
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1

	TNAME="test_generic_vlan_hw_rx<$recv>"

	verify_nic $send
	verify_nic $recv
	verify_num_groups_gte $recv 3
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic -v 5 $send $send_vn1
	create_vnic -v 5 $recv $recv_vn1
	create_addr $send_ip1 $send_vn1
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 hwlane

	delete_addr $send
	delete_addr $recv
	delete_interface $send_vn1
	delete_interface $recv_vn1
	delete_vnic $send_vn1
	delete_vnic $recv_vn1
	pass
}

#
# Verify correct migration of a VNIC from software to hardware Rx
# rings on any link that supports 3 or more mac groups.
#
function test_generic_sw_to_hw
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset recv_ip=${IPS[1]}
	typeset recv_ip1=${IPS[2]}
	typeset recv_vn1=mt_recv1

	TNAME="test_generic_sw_to_hw<$recv>"

	verify_nic $send
	verify_nic $recv
	verify_num_groups_gte $recv 3

	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic -s $recv $recv_vn1
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip $recv_ip1 $recv_vn1 swlane

	if ! dladm set-linkprop -p rxrings=hw $recv_vn1; then
		fail "failed to set rxrings=hw for $recv_vn1"
	fi

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip $recv_ip1 $recv_vn1 hwlane

	delete_addr $recv
	delete_addr $send
	delete_interface $recv_vn1
	delete_vnic $recv_vn1

	pass
}

function test_generic_promisc
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset recv_ip=${IPS[1]}
	typeset recv_ip1=${IPS[2]}
	typeset recv_ip_last=${IPS[3]}
	typeset recv_vn1="mt_recv1"

	TNAME="test_generic_promisc<$recv>"

	verify_nic $send
	verify_nic $recv
	create_addr $send_ip $send
	create_addr $recv_ip $recv

	#
	# We have to query the number of available filters AFTER the
	# recv_ip is created, as it consumes a filter.
	#
	integer num_l2_filt=$(get_num_l2_filt $recv)
	integer num_last=$(($num_l2_filt + 1))
	typeset recv_vn_last="mt_recv${num_last}"

	#
	# Create enough VNICs to consume all hardware L2 unicast filters.
	#
	for i in {1..$num_l2_filt}; do
		create_vnic $recv "mt_recv${i}"
	done

	#
	# Promisc shouldn't be on yet. We've consumed all filters but
	# it's not until the next client that we should need promisc mode.
	#
	if is_promisc $recv; then
		fail "$recv is unexpectedly in promisc mode"
	fi

	#
	# Okay, this VNIC should send us over the edge. We are out of
	# hardware filters; thus the only way to receive traffic for
	# this VNIC is by entering promisc mode.
	#
	create_vnic $recv $recv_vn_last
	if ! is_promisc $recv; then
		fail "$recv is not promisc mode"
	fi

	create_addr $recv_ip1 $recv_vn1
	create_addr $recv_ip_last $recv_vn_last

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip $recv_ip1 $recv_vn1 hwlane
	send_traffic $send_ip $recv_ip_last $recv_vn_last swlane

	delete_interface $recv_vn_last
	delete_interface $recv_vn1
	delete_addr $send
	delete_addr $recv
	for i in {1..$num_last}; do
		delete_vnic "mt_recv${i}"
	done
	pass
}

function test_generic_promisc_vlan
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset recv_ip_last=${IPS[4]}
	typeset send_vn1="mt_send1"
	typeset recv_vn1="mt_recv1"

	TNAME="test_generic_promisc_vlan<$recv>"

	verify_nic $send
	verify_nic $recv
	create_addr $send_ip $send
	create_addr $recv_ip $recv

	#
	# We have to query the number of available filters AFTER the
	# recv_ip is created, as it consumes a filter.
	#
	integer num_l2_filt=$(get_num_l2_filt $recv)
	integer num_last=$(($num_l2_filt + 1))
	typeset recv_vn_last="mt_recv${num_last}"

	#
	# Create enough VNICs to consume all hardware L2 unicast filters.
	#
	for i in {1..$num_l2_filt}; do
		create_vnic -v $vid $recv "mt_recv${i}"
	done

	#
	# Promisc shouldn't be on yet. We've consumed all filters but
	# it's not until the next client that we should need promisc mode.
	#
	if is_promisc $recv; then
		fail "$recv is unexpectedly in promisc mode"
	fi

	#
	# Okay, this VNIC should send us over the edge. We are out of
	# hardware filters; thus the only way to receive traffic for
	# this VNIC is by entering promisc mode.
	#
	create_vnic -v $vid $recv $recv_vn_last
	if ! is_promisc $recv; then
		fail "$recv is not promisc mode"
	fi

	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1
	create_addr $recv_ip1 $recv_vn1
	create_addr $recv_ip_last $recv_vn_last

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 hwlane
	send_traffic $send_ip1 $recv_ip_last $recv_vn_last swlane

	delete_interface $send_vn1
	delete_vnic $send_vn1
	delete_addr $recv_vn_last
	delete_interface $recv_vn_last
	delete_interface $recv_vn1
	delete_addr $send
	delete_addr $recv
	for i in {1..$num_last}; do
		delete_vnic "mt_recv${i}"
	done
	pass
}

#
# This test requires a NIC with at least 3 mac groups.
#
#	0) The default group.
#	1) The primary group.
#	2) The mt_recv1 group.
#
# Create N tagged VNICs, where N is the number of mac groups minus 2
# (to account for default and primary). Verify that the first N groups
# use reserved groups (hardware classification). Then verify that the
# primary and Nth group have their traffic hardware classified, and
# that the N+1 group gets software classification.
#
# N.B. If a NIC is capable of hosting more than 1024 mac groups, then
# this test may start giving you problems as the mac framework may
# create up to 24 threads per VNIC just for SRS fanout. This will
# cause you to start bumping up against thread space limitations. If
# this is the case the best course of action is to modify the drivers
# conf file to limit yourself to a smaller number of Rx groups.
#
function test_generic_vlan_all_groups
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset recv_ip_n=${IPS[4]}
	typeset recv_ip_np1=${IPS[5]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1

	TNAME="test_generic_vlan_all_groups<$recv>"

	verify_nic $send
	verify_nic $recv
	verify_num_groups_gte $recv 3

	integer num=$(($(get_num_groups $recv) - 2))
	typeset recv_vn_n="mt_recv$num"
	typeset recv_vn_np1="mt_recv$(($num + 1))"
	for i in {1..$num}; do
		typeset vn="mt_recv${i}"
		create_vnic -v $vid $recv $vn
		verify_hw $recv $vn
	done

	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_addr $recv_ip1 $recv_vn1
	create_addr $recv_ip_n $recv_vn_n
	create_vnic -v $vid $recv $recv_vn_np1
	create_addr $recv_ip_np1 $recv_vn_np1
	verify_sw $recv $recv_vn_np1
	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1

	send_traffic $send_ip1 $recv_ip1 $recv_vn1 hwlane
	send_traffic $send_ip1 $recv_ip_n $recv_vn_n hwlane
	send_traffic $send_ip1 $recv_ip_np1 $recv_vn_np1 swlane

	delete_interface $send_vn1
	delete_vnic $send_vn1
	delete_interface $recv_vn1
	delete_interface $recv_vn_n
	delete_interface $recv_vn_np1
	delete_vnic $recv_vn_np1
	delete_addr $recv
	delete_addr $send
	for i in {1..$num}; do
		delete_vnic "mt_recv${i}"
	done

	pass
}

#
# Create enough tagged VNICs to take all the reserved groups. Then
# create a tagged VNIC with rxrings=hw to induce the group stealing
# logic. Verify that this new cilent steals a group. Then verify that
# traffic is received on hwlane for the new client, and swlane for the
# client that had its group stolen.
#
function test_generic_vlan_steal_group
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset recv_ip_np1=${IPS[4]}
	typeset recv_ip_np2=${IPS[5]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1

	TNAME="test_generic_vlan_steal_group<$recv>"

	verify_nic $send
	verify_nic $recv
	verify_num_groups_gte $recv 3
	create_addr $send_ip $send
	create_addr $recv_ip $recv

	integer num=$(($(get_num_groups $recv) - 2))
	typeset recv_vn_np1="mt_recv$(($num + 1))"
	typeset recv_vn_np2="mt_recv$(($num + 2))"
	for i in {1..$num}; do
		typeset vn="mt_recv${i}"
		create_vnic -v $vid $recv $vn
		verify_hw $recv $vn
	done

	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 hwlane

	#
	# Create a new VLAN VNIC which explicitly requests HW Rx
	# rings. Since all reserved groups are taken at this point it
	# shoud steal the group from the first client which didn't
	# eplicitly request HW Rx rings: the primary client.
	#
	create_vnic -v $vid -h $recv $recv_vn_np1
	verify_hw $recv $recv_vn_np1
	verify_sw $recv $recv
	create_addr $recv_ip_np1 $recv_vn_np1

	send_traffic $send_ip $recv_ip $recv swlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 hwlane
	send_traffic $send_ip1 $recv_ip_np1 $recv_vn_np1 hwlane

	#
	# Create another VLAN VNIC requesting HW Rx rings. This should
	# steal another group, this time from the first VLAN VNIC: recv_vn1.
	#
	create_vnic -v $vid -h $recv $recv_vn_np2
	verify_hw $recv $recv_vn_np2
	verify_sw $recv $recv_vn1
	create_addr $recv_ip_np2 $recv_vn_np2

	send_traffic $send_ip $recv_ip $recv swlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane
	send_traffic $send_ip1 $recv_ip_np1 $recv_vn_np1 hwlane
	send_traffic $send_ip1 $recv_ip_np2 $recv_vn_np2 hwlane

	delete_addr $send
	delete_addr $recv
	delete_interface $send_vn1
	delete_vnic $send_vn1
	delete_interface $recv_vn1
	delete_interface $recv_vn_np1
	delete_vnic $recv_vn_np1
	delete_interface $recv_vn_np2
	delete_vnic $recv_vn_np2
	for i in {1..$num}; do
		delete_vnic mt_recv${i}
	done

	pass
}

#
# Verify that two tagged VNICs sharing the same MAC address are SW
# classified and that they are placed on the default group.
#
function test_generic_vlan_shared_addr
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset send_ip2=${IPS[2]}
	typeset recv_ip=${IPS[3]}
	typeset recv_ip1=${IPS[4]}
	typeset recv_ip2=${IPS[5]}
	typeset send_vn1=mt_send1
	typeset send_vn2=mt_send2
	typeset recv_vn1=mt_recv1
	typeset recv_vn2=mt_recv2

	TNAME="test_generic_vlan_shared_addr<$recv>"

	verify_nic $send
	verify_nic $recv
	verify_num_groups_gte $recv 2
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic -v 5 $send $send_vn1
	create_vnic -v 6 $send $send_vn2
	create_vnic -v 5 $recv $recv_vn1
	typeset recv_vn1_addr=$(get_macaddr $recv_vn1)
	create_vnic -m $recv_vn1_addr -v 6 $recv $recv_vn2
	typeset recv_vn2_addr=$(get_macaddr $recv_vn2)

	if [[ "$recv_vn1_addr" != "$recv_vn2_addr" ]]; then
		fail "VNICs $recv_vn1 and $recv_vn2 don't have the same" \
		     " MAC address: $recv_vn1_addr != $recv_vn2_addr"
	fi

	kstat -p $recv_vn1:::rbytes | grep hwlane > /dev/null
	if [[ $? -eq 0 ]]; then
		fail "VNIC $recv_vn1 shouldn't have HW lanes"
	fi

	kstat -p $recv_vn2:::rbytes | grep hwlane > /dev/null
	if [[ $? -eq 0 ]]; then
		fail "VNIC $recv_vn2 shouldn't have HW lanes"
	fi

	create_addr $send_ip1 $send_vn1
	create_addr $send_ip2 $send_vn2
	create_addr $recv_ip1 $recv_vn1
	create_addr $recv_ip2 $recv_vn2

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane
	send_traffic $send_ip2 $recv_ip2 $recv_vn2 swlane

	delete_addr $send
	delete_addr $recv
	delete_interface $send_vn1
	delete_interface $send_vn2
	delete_interface $recv_vn1
	delete_interface $recv_vn2
	delete_vnic $send_vn1
	delete_vnic $send_vn2
	delete_vnic $recv_vn1
	delete_vnic $recv_vn2
	pass
}

#
# Place two tagged VNICs sharing a VID on the default group via
# rxrings=sw. Verify traffic is seen on both. Then delete one and
# verify traffic is still seen on remaining VLAN VNIC.
#
function test_generic_two_vlans_on_default
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset recv_ip2=${IPS[4]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1
	typeset recv_vn2=mt_recv2

	TNAME="test_generic_two_vlan_on_default<$recv>"

	verify_nic $send
	verify_nic $recv
	verify_num_groups_gte $recv 2
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1
	create_vnic -v $vid -s $recv $recv_vn1
	create_vnic -v $vid -s $recv $recv_vn2
	verify_sw $recv $recv_vn1
	verify_sw $recv $recv_vn2
	create_addr $recv_ip1 $recv_vn1
	create_addr $recv_ip2 $recv_vn2

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane
	send_traffic $send_ip1 $recv_ip2 $recv_vn2 swlane

	delete_interface $recv_vn2
	delete_vnic $recv_vn2

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane

	delete_addr $send
	delete_addr $recv
	delete_interface $send_vn1
	delete_vnic $send_vn1
	delete_interface $recv_vn1
	delete_vnic $recv_vn1

	pass
}

#
# TODO: At first this I wrote this test to create 4095 VLANs, but it
# turns out SRS fanout causes an explosion of soft ring workers
# threads and exhausts the thread space. That will be the subject of a
# future bug. For now we test something a bit more reasonable but also
# probably much bigger than anyuthing anyone is running in production.
#
# Verify that 1024 VLANs can coexist and receive traffic on ixgbe. We
# start with VID 2 because 1 is reserved by the default_tag.
#
function test_ixgbe_many_vlans
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset send_ip2=${IPS[1]}
	typeset send_ip1025=${IPS[2]}
	typeset recv_ip=${IPS[3]}
	typeset recv_ip2=${IPS[4]}
	typeset recv_ip1025=${IPS[5]}
	typeset send_vn2="mt_send2"
	typeset send_vn1025="mt_send1025"
	typeset recv_vn2="mt_recv2"
	typeset recv_vn1025="mt_recv1025"

	TNAME="test_ixgbe_many_vlans<$recv>"

	verify_nic $send
	verify_nic $recv
	verify_nic_type $recv ixgbe
	create_addr $send_ip $send
	create_addr $recv_ip $recv

	#
	# Create 4095 VNICs, each on a unique VLAN. We don't create
	# VID 1 because it's reserved as the default_tag.
	#
	for vid in {2..1025}; do
		create_vnic -v $vid $recv "mt_recv${vid}"
	done

	create_vnic -v 2 $send $send_vn2
	create_addr $send_ip2 $send_vn2
	create_vnic -v 1025 $send $send_vn1025
	create_addr $send_ip1025 $send_vn1025
	create_addr $recv_ip2 $recv_vn2
	create_addr $recv_ip1025 $recv_vn1025

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip2 $recv_ip2 $recv_vn2 hwlane
	send_traffic $send_ip1025 $recv_ip1025 $recv_vn1025 swlane

	delete_interface $send_vn1025
	delete_interface $send_vn2
	delete_interface $recv_vn1025
	delete_interface $recv_vn2
	delete_vnic $send_vn1025
	delete_vnic $send_vn2
	delete_addr $send
	delete_addr $recv
	for vid in {2..1025}; do
		delete_vnic "mt_recv${vid}"
	done

	pass
}

#
# VFTA: VLAN Filter Table Array. Used in the L2 filtering stage. A
# bitmap of VIDs to pass to the host. If a VID is missing from this
# table then it is dropped by the controller.
#
# VLVF: VLAN Pool Filter. Used in the swtiching stage. A bitmap of
# pools which are participating in the VID specified in this filter.
# There are 64 of these filters. If you have 64 Rx groups each in
# their own VLAN then you will need all 64 VLVF slots -- where each
# one will indicate the VID and set one bit for its corresponding
# pool.
#
# This test is designed to induce a state where ixgbe disables the VID
# entry in the VFTA because the controller doesn't reference count the
# number of clients sharing the same VID in the default group. For
# example, if you had two mac clients on the default group, both a
# member of VLAN 7, and no other clients interested in VLAN 7, then
# removing one of those clients and calling ixgbe_set_vfta() to
# disable the VID would cause its removal from the VFTA, causing the
# traffic for the remaining client to be dropped at the filtering
# stage. Instead, we have code in the driver to reference count the
# VID usage on the default group and make sure the VFTA entry is
# cleared only on removal of the final client.
#
# Requirements:
#
#	o We have two ixgbe ports.
#
#	o The recv port is configured with 32 Rx groups.
#
#	o The recv port has one Rx group already consumed by the
#	  primary client
#
# 1. Create 30 tagged VNICs with the same vid. These MAC clients will
#    consume all the RESERVED groups and utilize a single VLVF slot.
#
# 2. Create 2 more tagged VNICs with the same vid as the first 31.
#    These two clients will end up on the default (SHARED) group. When
#    calling ixgbe_set_vfta() we will set vlvf_bypass to true but
#    since this VID exists in the VLVF we'll toggle the default
#    group's bit in VLVFB[vid].
#
# 3. Verify TCP traffic can pass thru the last VNIC created.
#
# 4. Delete the first 30 VNICs. This will relinquish all the RESERVED
#    groups and delete their indexes from the VLVFB[vid] slot. At this
#    point only the default group's bit is set.
#
# 5. Reverify TCP traffic can pass thru the last VNIC created.
#
# 6. Delete the second to last VNIC (on the default group). This will
#    disable the default group's bit in VLVFB[vid] even though the
#    last VNIC is still interested in that VLAN. However, the
#    switching logic doesn't depend on this because the default pool
#    is enabled. And the logic in ixgbe_remvlan() will prevent us from
#    clearing the VFTA bit while there is still a client for the VID.
#
# 7. Reverify TCP traffic can pass thru the last VNIC created.
#
function test_ixgbe_vfta_repeated_vid
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset send_vn1=mt_send1

	TNAME="test_ixgbe_vfta_repeated_vid<$recv>"

	verify_nic $send
	verify_nic $recv
	verify_nic_type $send ixgbe
	verify_nic_type $recv ixgbe
	#
	# TODO: Rewrite this to be generic re the number of groups.
	#
	verify_num_groups $recv 32
	create_addr $send_ip $send
	create_addr $recv_ip $recv

	for i in {1..30}; do
		create_vnic -v $vid $recv mt_recv${i}
	done

	dladm show-phys -po ringtype,clients -H $recv | \
		grep -v TX | grep '\-\-'
	if [[ $? -eq 0 ]]; then
		fail "all Rx groups should be reserved on $recv"
	fi

	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1
	create_vnic -v $vid $recv mt_recv31
	create_vnic -v $vid $recv mt_recv32
	create_addr $recv_ip1 mt_recv32

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 mt_recv32 swlane

	for i in {1..30}; do
		delete_vnic mt_recv${i}
	done

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 mt_recv32 swlane

	delete_vnic mt_recv31

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 mt_recv32 swlane

	delete_addr $send
	delete_addr $recv
	delete_interface mt_recv32
	delete_vnic mt_recv32
	delete_interface $send_vn1
	delete_vnic $send_vn1

	pass
}

#
# This is another edge case test related to test_vfta_repeated_vid.
# There are cases where a client on a non-default group could share a
# VLAN with a client on the default group, but the default group
# doesn't have its bit enabled in the VLVFB for that VLAN. Then, if
# the client on the non-default group is deleted, it will clear the
# VFTA bit and the client on the default group will stop receiving
# traffic. We have code in the driver to catch this case and re-enable
# the VFTA bit so that traffic will continue to flow for the remaning
# client. This test verifies that code works.
#
# 1. Create tagged VNIC 1 with property rxrings=sw. This will place it
#    on the default Rx group.
#
# 2. Create tagged VNIC 2 with the same VID but don't set the
#    property. This client will be placed on a non-default Rx group.
#
# 3. Verify traffic can flow over VNIC 1.
#
# 4. Delete VNIC 2.
#
# 5. Verify traffic can flow over VNIC 1.
#
function test_ixgbe_vlvfb_missing_default
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1
	typeset recv_vn2=mt_recv2

	TNAME="test_ixgbe_missing_default<$recv>"

	verify_nic $send
	verify_nic $recv
	verify_nic_type $send ixgbe
	verify_nic_type $recv ixgbe
	#
	# TODO: Fix this to be generic re number of mac groups.
	#
	verify_num_groups $recv 32
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic -v $vid $send $send_vn1
	create_vnic -v $vid -s $recv $recv_vn1
	verify_sw $recv $recv_vn1
	create_vnic -v $vid $recv $recv_vn2
	verify_hw $recv $recv_vn2
	create_addr $send_ip1 $send_vn1
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane

	delete_vnic $recv_vn2

	send_traffic $send_ip $recv_ip $recv hwlane
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane

	delete_addr $send
	delete_addr $recv
	delete_interface $send_vn1
	delete_vnic $send_vn1
	delete_interface $recv_vn1
	delete_vnic $recv_vn1

	pass
}

#
# Verify that Rx data travels over HW lanes when using just the aggr's
# primary MAC client.
#
function test_generic_aggr_primary
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset recv_ip=${IPS[1]}
	typeset classify=swlane

	TNAME="test_generic_aggr_primary<$recv>"

	create_addr $send_ip $send
	create_addr $recv_ip $recv

	#
	# This should expect hardware classification (hwlane) post
	# aggr mac groups (SmartOS OS-6719), however:
	#
	# 1. This fails on 9000 MTU because the port SDU change causes
	#    us to enter SW classify (verified on SmartOS only, not
	#    sure if this holds for other distros).
	#
	# 2. This fails without MTU change because the primary client
	#    ends up on the default group. This should be fixed in a
	#    follow up.
	#
	if (($PRE_AGGR_MAC_GROUP == 1)); then
	   classify=hwlane
	fi
	send_traffic $send_ip $recv_ip $recv $classify

	delete_interface $send
	delete_interface $recv

	pass
}

#
# Verify that Rx data travels over software lanes when using a VLAN on
# the primary MAC addr. I.e., created with create-vlan.
#
function test_generic_aggr_primary_vlan
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1

	TNAME="test_generic_aggr_primary_vlan<$recv>"

	verify_aggr $send
	verify_aggr $recv
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		typeset recv_port1=$(dladm show-aggr -xpo port $recv | \
						    sed -n '2p')
		typeset recv_port2=$(dladm show-aggr -xpo port $recv | \
						    sed -n '3p')
		verify_num_groups_gte $recv_port1 3
		verify_num_groups_gte $recv_port2 3
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1
	dladm create-vlan -t -l $recv -v $vid $recv_vn1
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane

	delete_interface $send
	delete_interface $recv
	delete_interface $send_vn1
	delete_interface $recv_vn1
	delete_vnic $send_vn1
	if ! dladm delete-vlan -t $recv_vn1; then
		fail "failed to delete VLAN $recv_vn"
	fi

	pass
}

function test_generic_aggr_vnic
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset recv_ip=${IPS[1]}
	typeset recv_ip1=${IPS[2]}
	typeset recv_vn1=mt_recv1

	TNAME="test_generic_aggr_vnic<$recv>"

	verify_aggr $send
	verify_aggr $recv
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		typeset recv_port1=$(dladm show-aggr -xpo port $recv | \
						    sed -n '2p')
		typeset recv_port2=$(dladm show-aggr -xpo port $recv | \
						    sed -n '3p')
		verify_num_groups_gte $recv_port1 3
		verify_num_groups_gte $recv_port2 3
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic $recv $recv_vn1
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip $recv_ip1 $recv_vn1 $CLASSIFY

	delete_interface $send
	delete_interface $recv
	delete_interface $recv_vn1
	delete_vnic $recv_vn1

	pass
}

#
# Verify that two VNICs can coexist on the same aggr and receive traffic.
#
function test_generic_aggr_two_vnics
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset recv_ip=${IPS[1]}
	typeset recv_ip1=${IPS[2]}
	typeset recv_ip2=${IPS[3]}
	typeset recv_vn1=mt_recv1
	typeset recv_vn2=mt_recv2

	TNAME="test_generic_aggr_two_vnics<$recv>"

	verify_aggr $send
	verify_aggr $recv
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		typeset recv_port1=$(dladm show-aggr -xpo port $recv | \
						    sed -n '2p')
		typeset recv_port2=$(dladm show-aggr -xpo port $recv | \
						    sed -n '3p')
		verify_num_groups_gte $recv_port1 4
		verify_num_groups_gte $recv_port2 4
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic $recv $recv_vn1
	create_addr $recv_ip1 $recv_vn1
	create_vnic $recv $recv_vn2
	create_addr $recv_ip2 $recv_vn2

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip $recv_ip1 $recv_vn1 $CLASSIFY
	send_traffic $send_ip $recv_ip2 $recv_vn2 $CLASSIFY

	delete_interface $send
	delete_interface $recv
	delete_interface $recv_vn1
	delete_vnic $recv_vn1
	delete_interface $recv_vn2
	delete_vnic $recv_vn2

	pass
}

#
# Verify that a single tagged VNIC on an aggr receives traffic via hardware
# classification.
#
function test_generic_aggr_vlan
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1

	TNAME="test_generic_aggr_vlan<$recv>"

	verify_aggr $send
	verify_aggr $recv
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		typeset recv_port1=$(dladm show-aggr -xpo port $recv | \
						    sed -n '2p')
		typeset recv_port2=$(dladm show-aggr -xpo port $recv | \
						    sed -n '3p')
		verify_num_groups_gte $recv_port1 3
		verify_num_groups_gte $recv_port2 3
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1
	create_vnic -v $vid $recv $recv_vn1
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 $CLASSIFY

	delete_interface $send
	delete_interface $recv
	delete_interface $recv_vn1
	delete_vnic $recv_vn1
	delete_interface $send_vn1
	delete_vnic $send_vn1

	pass
}

#
# Verify that two tagged VNICs on the same aggr receive traffic via
# hardware classification.
#
function test_generic_aggr_two_vlans
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset recv_ip2=${IPS[4]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1
	typeset recv_vn2=mt_recv2

	TNAME="test_generic_aggr_two_vlans<$recv>"

	verify_aggr $send
	verify_aggr $recv
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		typeset recv_port1=$(dladm show-aggr -xpo port $recv | \
						    sed -n '2p')
		typeset recv_port2=$(dladm show-aggr -xpo port $recv | \
						    sed -n '3p')
		verify_num_groups_gte $recv_port1 3
		verify_num_groups_gte $recv_port2 3
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic -v $vid $recv $recv_vn1
	create_addr $recv_ip1 $recv_vn1
	create_vnic -v $vid $recv $recv_vn2
	create_addr $recv_ip2 $recv_vn2
	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 $CLASSIFY
	send_traffic $send_ip1 $recv_ip2 $recv_vn2 $CLASSIFY

	delete_interface $send
	delete_interface $recv
	delete_interface $recv_vn1
	delete_vnic $recv_vn1
	delete_interface $recv_vn2
	delete_vnic $recv_vn2
	delete_interface $send_vn1
	delete_vnic $send_vn1

	pass
}

#
# Verify that two tagged VNICs sharing the same MAC address are
# software classified and that they are placed on the default group.
#
function test_generic_aggr_vlans_shared_addr
{
	typeset send=$1
	typeset recv=$2
	typeset vid1=$3
	typeset vid2=$4
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset send_ip2=${IPS[2]}
	typeset recv_ip=${IPS[3]}
	typeset recv_ip1=${IPS[4]}
	typeset recv_ip2=${IPS[5]}
	typeset send_vn1="mt_send1"
	typeset send_vn2="mt_send2"
	typeset recv_vn1="mt_recv1"
	typeset recv_vn2="mt_recv2"

	TNAME="test_generic_aggr_vlans_shared_addr"

	verify_aggr $send
	verify_aggr $recv
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		typeset recv_port1=$(dladm show-aggr -xpo port $recv | \
						    sed -n '2p')
		typeset recv_port2=$(dladm show-aggr -xpo port $recv | \
						    sed -n '3p')
		verify_num_groups_gte $recv_port1 2
		verify_num_groups_gte $recv_port2 2
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic -v $vid1 $send $send_vn1
	create_vnic -v $vid2 $send $send_vn2
	create_vnic -v $vid1 $recv $recv_vn1
	typeset addr1=$(get_macaddr $recv_vn1)
	create_vnic -m $addr1 -v $vid2 $recv $recv_vn2
	typeset addr2=$(get_macaddr $recv_vn2)

	if [[ "$addr1" != "$addr2" ]]; then
		fail "VNICs $recv_vn1 and $recv_vn2 don't have the same" \
		     "MAC address: $addr1 != $addr2"
	fi

	kstat -p $recv_vn1:::rbytes | grep hwlane > /dev/null
	if [[ $? -eq 0 ]]; then
		fail "VNIC $recv_vn1 shouldn't have HW lanes"
	fi

	kstat -p $recv_vn2:::rbytes | grep hwlane > /dev/null
	if [[ $? -eq 0 ]]; then
		fail "VNIC $recv_vn2 shouldn't have HW lanes"
	fi

	create_addr $send_ip1 $send_vn1
	create_addr $send_ip2 $send_vn2
	create_addr $recv_ip1 $recv_vn1
	create_addr $recv_ip2 $recv_vn2

	send_traffic $send_ip1 $recv_ip1 $recv_vn1 $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane
	send_traffic $send_ip2 $recv_ip2 $recv_vn2 swlane

	delete_interface $send
	delete_interface $recv
	delete_interface $send_vn1
	delete_vnic $send_vn1
	delete_interface $send_vn2
	delete_vnic $send_vn2
	delete_interface $recv_vn1
	delete_vnic $recv_vn1
	delete_interface $recv_vn2
	delete_vnic $recv_vn2

	pass
}


#
# Verify that if you have 2 VNICs and delete one that the remaining
# VNIC can still receive traffic.
#
function test_generic_aggr_ref_count
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset recv_ip2=${IPS[4]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1
	typeset recv_vn2=mt_recv2

	TNAME="test_generic_aggr_ref_count<$recv>"

	verify_aggr $send
	verify_aggr $recv
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		typeset recv_port1=$(dladm show-aggr -xpo port $recv | \
						    sed -n '2p')
		typeset recv_port2=$(dladm show-aggr -xpo port $recv | \
						    sed -n '3p')
		verify_num_groups_gte $recv_port1 4
		verify_num_groups_gte $recv_port2 4
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic $send $send_vn1
	create_addr $send_ip1 $send_vn1
	create_vnic $recv $recv_vn1
	create_addr $recv_ip1 $recv_vn1
	create_vnic $recv $recv_vn2
	create_addr $recv_ip2 $recv_vn2

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 $CLASSIFY
	send_traffic $send_ip1 $recv_ip2 $recv_vn2 $CLASSIFY

	delete_interface $recv_vn2
	delete_vnic $recv_vn2

	send_traffic $send_ip1 $recv_ip1 $recv_vn1 $CLASSIFY

	delete_interface $send
	delete_interface $recv
	delete_interface $recv_vn1
	delete_vnic $recv_vn1
	delete_interface $send_vn1
	delete_vnic $send_vn1

	pass
}

#
# Verify that aggr of two ixgbe ports enters promisc mode once all L2
# unicast filters have been consumed.
#
function test_aggr_ixgbe_promisc
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset recv_ip=${IPS[1]}
	typeset recv_ip1=${IPS[2]}
	typeset recv_ip_last=${IPS[3]}
	typeset recv_vn1="mt_recv1"

	TNAME="test_aggr_ixgbe_promisc<$recv>"

	verify_aggr $send
	verify_aggr $recv
	typeset recv_port1=$(dladm show-aggr -xpo port $recv | sed -n '2p')
	typeset recv_port2=$(dladm show-aggr -xpo port $recv | sed -n '3p')
	verify_nic_type $recv_port1 ixgbe
	verify_nic_type $recv_port2 ixgbe
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		verify_num_groups_gte $recv_port1 3
		verify_num_groups_gte $recv_port2 3
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv

	#
	# We have to query the number of available filters AFTER the
	# recv_ip is created, as it consumes a filter.
	#
	# This has to use double quotes to avoid the shell from
	# inserting a newline at the line continuation, thus causing
	# grief for mdb when it tries to run the expression.
	#
	integer num_l2_filt=$(get_ixgbe_num_l2_filt $recv_port1)
	integer num_l2_filt_2=$(get_ixgbe_num_l2_filt $recv_port2)
	if (($num_l2_filt != $num_l2_filt_2)); then
		fail "$recv_port1 L2 filters != $recv_port2 L2 filters" \
		     "($num_l2_filt != $num_l2_filt)"
	fi
	#
	# TODO: We have a bug somewhere in mac/aggr that doesn't allow
	# us to make use of the first reserved group (index 1) of the
	# underlying ports. Until this is fixed we must adjust by one.
	#
	if (($PRE_AGGR_MAC_GROUP == 1)); then
		#
		# In this case the ports have num_l2_filt filters, but
		# the aggr doesn't yet have groups so it can't make
		# use of filter slots 1-32.
		#
		integer num_l2_filt=$(($num_l2_filt - 31))
	else
		integer num_l2_filt=$(($num_l2_filt - 1))
	fi
	integer num_last=$(($num_l2_filt + 1))
	typeset recv_vn_last="mt_recv${num_last}"

	for i in {1..$num_l2_filt}; do
		create_vnic $recv "mt_recv${i}"
	done

	if is_promisc $recv_port1; then
		fail "$recv_port1 is unexpectedly in promisc mode"
	fi

	if is_promisc $recv_port2; then
		fail "$recv_port2 is unexpectedly in promisc mode"
	fi

	#
	# This VNIC should send us over the edge. We are out of
	# hardware L2 filters; thus the ports must enter promisc mode.
	#
	create_vnic $recv $recv_vn_last

	if ! is_promisc $recv_port1; then
		fail "$recv_port1 is not in promisc mode"
	fi

	if ! is_promisc $recv_port2; then
		fail "$recv_port2 is not in promisc mode"
	fi

	create_interface $recv_vn1
	create_addr $recv_ip1 $recv_vn1
	create_interface $recv_vn_last
	create_addr $recv_ip_last $recv_vn_last

	if (($PRE_AGGR_MAC_GROUP == 1)); then
		send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
		send_traffic $send_ip $recv_ip1 $recv_vn1 swlane
		send_traffic $send_ip $recv_ip_last $recv_vn_last swlane
	else
		send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
		send_traffic $send_ip $recv_ip1 $recv_vn1 hwlane
		send_traffic $send_ip $recv_ip_last $recv_vn_last swlane
	fi

	delete_interface $recv_vn_last
	delete_interface $recv_vn1
	delete_interface $send
	delete_interface $recv
	for i in {1..$num_last}; do
		delete_vnic "mt_recv${i}"
	done

	pass
}

#
# This is identifcal to test_aggr_ixgbe_promisc, except for the fact
# it uses tagged VNICs.
#
function test_aggr_vlan_ixgbe_promisc
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset recv_ip_last=${IPS[4]}
	typeset send_vn1="mt_send1"
	typeset recv_vn1="mt_recv1"

	TNAME="test_aggr_vlan_ixgbe_promisc"

	verify_aggr $send
	verify_aggr $recv
	typeset recv_port1=$(dladm show-aggr -xpo port $recv | sed -n '2p')
	typeset recv_port2=$(dladm show-aggr -xpo port $recv | sed -n '3p')
	verify_nic_type $recv_port1 ixgbe
	verify_nic_type $recv_port2 ixgbe
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		verify_num_groups_gte $recv_port1 3
		verify_num_groups_gte $recv_port2 3
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv

	#
	# We have to query the number of available filters AFTER the
	# recv_ip is created, as it consumes a filter.
	#
	# This has to use double quotes to avoid the shell from
	# inserting a newline at the line continuation, thus causing
	# grief for mdb when it tries to run the expression.
	#
	integer num_l2_filt=$(get_ixgbe_num_l2_filt $recv_port1)
	integer num_l2_filt_2=$(get_ixgbe_num_l2_filt $recv_port2)
	if (($num_l2_filt != $num_l2_filt_2)); then
		fail "$recv_port1 L2 filters != $recv_port2 L2 filters" \
		     "($num_l2_filt != $num_l2_filt)"
	fi
	#
	# TODO: We have a bug somewhere in mac/aggr that doesn't allow
	# us to make use of the first reserved group (index 1) of the
	# underlying ports. Until this is fixed we must adjust by one.
	#
	if (($PRE_AGGR_MAC_GROUP == 1)); then
		#
		# In this case the ports have num_l2_filt filters, but
		# the aggr doesn't yet have groups so it can't make
		# use of filter slots 1-32.
		#
		integer num_l2_filt=$(($num_l2_filt - 31))
	else
		integer num_l2_filt=$(($num_l2_filt - 1))
	fi
	integer num_last=$(($num_l2_filt + 1))
	typeset recv_vn_last="mt_recv${num_last}"
	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1
	for i in {1..$num_l2_filt}; do
		create_vnic -v $vid $recv "mt_recv${i}"
	done

	if is_promisc $recv_port1; then
		fail "$recv_port1 is unexpectedly in promisc mode"
	fi

	if is_promisc $recv_port2; then
		fail "$recv_port2 is unexpectedly in promisc mode"
	fi

	#
	# This VNIC should send us over the edge. We are out of
	# hardware L2 filters; thus the ports must enter promisc mode.
	#
	create_vnic -v $vid $recv $recv_vn_last

	if ! is_promisc $recv_port1; then
		fail "$recv_port1 is not in promisc mode"
	fi

	if ! is_promisc $recv_port2; then
		fail "$recv_port2 is not in promisc mode"
	fi

	create_addr $recv_ip1 $recv_vn1
	create_addr $recv_ip_last $recv_vn_last

	if (($PRE_AGGR_MAC_GROUP == 1)); then
		send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
		send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane
		send_traffic $send_ip1 $recv_ip_last $recv_vn_last swlane
	else
		send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
		send_traffic $send_ip1 $recv_ip1 $recv_vn1 hwlane
		send_traffic $send_ip1 $recv_ip_last $recv_vn_last swlane
	fi

	delete_interface $recv_vn_last
	delete_interface $recv_vn1
	delete_interface $send_vn1
	delete_interface $send
	delete_interface $recv
	delete_vnic $send_vn1
	for i in {1..$num_last}; do
		delete_vnic "mt_recv${i}"
	done

	pass
}

function test_generic_aggr_steal_group
{
	typeset send=$1
	typeset recv=$2
	typeset send_ip=${IPS[0]}
	typeset recv_ip=${IPS[1]}
	typeset recv_ip1=${IPS[2]}
	typeset recv_ip_np1=${IPS[3]}
	typeset recv_ip_np2=${IPS[4]}
	typeset recv_vn1=mt_recv1

	TNAME="test_generic_aggr_steal_group<$recv>"

	verify_aggr $send
	verify_aggr $recv
	typeset recv_port1=$(dladm show-aggr -xpo port $recv | sed -n '2p')
	typeset recv_port2=$(dladm show-aggr -xpo port $recv | sed -n '3p')
	verify_nic_type $recv_port1 ixgbe
	verify_nic_type $recv_port2 ixgbe
	verify_num_groups_gte $recv_port1 3
	verify_num_groups_gte $recv_port2 3
	integer num1=$(($(get_num_groups $recv_port1) - 2))
	integer num2=$(($(get_num_groups $recv_port2) - 2))
	if (($num1 != $num2)); then
		fail "aggr ports $recv_port1 and $recv_port2 have different" \
		     "number of groups ($num1 != $num2)"
	fi
	typeset recv_vn_np1="mt_recv$(($num1 + 1))"
	typeset recv_vn_np2="mt_recv$(($num1 + 2))"
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	for i in {1..$num1}; do
		create_vnic $recv mt_recv${i}
	done
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip $recv_ip1 $recv_vn1 hwlane

	#
	# Create a new VNIC which explicitly requests hardware Rx
	# rings. Since all reserved groups are taken at this point it
	# should steal the group from the first client which didn't
	# explicitly request HW rings: the primary client.
	#
	create_vnic -h $recv $recv_vn_np1
	create_addr $recv_ip_np1 $recv_vn_np1

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip $recv_ip1 $recv_vn1 hwlane
	send_traffic $send_ip $recv_ip_np1 $recv_vn_np1 hwlane

	#
	# Create another VNIC requesting HW Rx rings. This should
	# steal another group, this time from the first VNIC: recv_vn1.
	#
	create_vnic -h $recv $recv_vn_np2
	create_addr $recv_ip_np2 $recv_vn_np2

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip $recv_ip1 $recv_vn1 swlane
	send_traffic $send_ip $recv_ip_np1 $recv_vn_np1 hwlane
	send_traffic $send_ip $recv_ip_np2 $recv_vn_np2 hwlane

	delete_interface $send
	delete_interface $recv
	delete_interface $recv_vn1
	delete_interface $recv_vn_np1
	delete_interface $recv_vn_np2
	delete_vnic $recv_vn_np1
	delete_vnic $recv_vn_np2
	for i in {1..$num1}; do
		delete_vnic mt_recv${i}
	done

	pass
}

function test_generic_aggr_vlan_steal_group
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset recv_ip_np1=${IPS[4]}
	typeset recv_ip_np2=${IPS[5]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1

	TNAME="test_generic_aggr_vlan_steal_group<$recv>"

	verify_aggr $send
	verify_aggr $recv
	typeset recv_port1=$(dladm show-aggr -xpo port $recv | sed -n '2p')
	typeset recv_port2=$(dladm show-aggr -xpo port $recv | sed -n '3p')
	verify_nic_type $recv_port1 ixgbe
	verify_nic_type $recv_port2 ixgbe
	verify_num_groups_gte $recv_port1 3
	verify_num_groups_gte $recv_port2 3
	integer num1=$(($(get_num_groups $recv_port1) - 2))
	integer num2=$(($(get_num_groups $recv_port2) - 2))
	if (($num1 != $num2)); then
		fail "aggr ports $recv_port1 and $recv_port2 have different" \
		     "number of groups ($num1 != $num2)"
	fi
	typeset recv_vn_np1="mt_recv$(($num1 + 1))"
	typeset recv_vn_np2="mt_recv$(($num1 + 2))"
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	for i in {1..$num1}; do
		create_vnic -v $vid $recv mt_recv${i}
	done
	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 hwlane

	#
	# Create a new VNIC which explicitly requests hardware Rx
	# rings. Since all reserved groups are taken at this point it
	# should steal the group from the first client which didn't
	# explicitly request HW rings: the primary client.
	#
	create_vnic -h -v $vid $recv $recv_vn_np1
	create_interface $recv_vn_np1
	create_addr $recv_ip_np1 $recv_vn_np1

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip_np1 $recv_vn_np1 hwlane

	#
	# Create another VNIC requesting HW Rx rings. This should
	# steal another group, this time from the first VNIC: recv_vn1.
	#
	create_vnic -h -v $vid $recv $recv_vn_np2
	create_addr $recv_ip_np2 $recv_vn_np2

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane
	send_traffic $send_ip1 $recv_ip_np1 $recv_vn_np1 hwlane
	send_traffic $send_ip1 $recv_ip_np2 $recv_vn_np2 hwlane

	delete_interface $send
	delete_interface $recv
	delete_interface $send_vn1
	delete_interface $recv_vn1
	delete_interface $recv_vn_np1
	delete_interface $recv_vn_np2
	delete_vnic $send_vn1
	for i in {1..$(($num1 + 2))}; do
		delete_vnic mt_recv${i}
	done

	pass
}

#
# Verify that if you have two tagged VNICs on the same VLAN and you
# delete one of them, that the other still receives traffic. This
# verifies the VLAN ref counting in aggr.
#
function test_generic_aggr_vlan_ref_count
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset recv_ip=${IPS[2]}
	typeset recv_ip1=${IPS[3]}
	typeset recv_ip2=${IPS[4]}
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1
	typeset recv_vn2=mt_recv2

	TNAME="test_generic_aggr_vlan_ref_count<$recv>"

	verify_aggr $send
	verify_aggr $recv
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		typeset recv_port1=$(dladm show-aggr -xpo port $recv | \
						    sed -n '2p')
		typeset recv_port2=$(dladm show-aggr -xpo port $recv | \
						    sed -n '3p')
		verify_num_groups_gte $recv_port1 4
		verify_num_groups_gte $recv_port2 4
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic -v $vid $recv $recv_vn1
	create_addr $recv_ip1 $recv_vn1
	create_vnic -v $vid $recv $recv_vn2
	create_addr $recv_ip2 $recv_vn2
	create_vnic -v $vid $send $send_vn1
	create_addr $send_ip1 $send_vn1

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 $CLASSIFY
	send_traffic $send_ip1 $recv_ip2 $recv_vn2 $CLASSIFY

	delete_interface $recv_vn2
	delete_vnic $recv_vn2

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 $CLASSIFY

	delete_interface $send
	delete_interface $recv
	delete_interface $recv_vn1
	delete_vnic $recv_vn1
	delete_interface $send_vn1
	delete_vnic $send_vn1

	pass
}

#
# Verify that an untagged VNIC and tagged VNIC can coexist on the same
# aggr and still receive data.
#
function test_generic_aggr_vnic_and_vlan
{
	typeset send=$1
	typeset recv=$2
	typeset vid=$3
	typeset send_ip=${IPS[0]}
	typeset send_ip1=${IPS[1]}
	typeset send_ip2=${IPS[2]}
	typeset recv_ip=${IPS[3]}
	typeset recv_ip1=${IPS[4]}
	typeset recv_ip2=${IPS[5]}
	typeset send_vn1=mt_send1
	typeset send_vn2=mt_send2
	typeset recv_vn1=mt_recv1
	typeset recv_vn2=mt_recv2

	TNAME="test_generic_aggr_vnic_and_vlan<$recv>"

	verify_aggr $send
	verify_aggr $recv
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		typeset recv_port1=$(dladm show-aggr -xpo port $recv | \
						    sed -n '2p')
		typeset recv_port2=$(dladm show-aggr -xpo port $recv | \
						    sed -n '3p')
		verify_num_groups_gte $recv_port1 4
		verify_num_groups_gte $recv_port2 4
	fi
	create_addr $send_ip $send
	create_addr $recv_ip $recv
	create_vnic $recv $recv_vn1
	create_addr $recv_ip1 $recv_vn1
	create_vnic -v $vid $recv $recv_vn2
	create_addr $recv_ip2 $recv_vn2
	create_vnic $send $send_vn1
	create_addr $send_ip1 $send_vn1
	create_vnic -v $vid $send $send_vn2
	create_addr $send_ip2 $send_vn2

	send_traffic $send_ip $recv_ip $recv $PRIMARY_CLASSIFY
	send_traffic $send_ip1 $recv_ip1 $recv_vn1 $CLASSIFY
	send_traffic $send_ip2 $recv_ip2 $recv_vn2 $CLASSIFY

	delete_interface $send
	delete_interface $recv
	delete_interface $recv_vn1
	delete_interface $recv_vn2
	delete_interface $send_vn1
	delete_interface $send_vn2
	delete_vnic $recv_vn1
	delete_vnic $recv_vn2
	delete_vnic $send_vn1
	delete_vnic $send_vn2

	pass
}

#
# Verify VLANs work on Etherstubs.
#
function test_etherstub_vlan
{
	typeset send_ip1=$1
	typeset recv_ip1=$2
	typeset vid=$3
	typeset stub=mt_stub1
	typeset send_vn1=mt_send1
	typeset recv_vn1=mt_recv1

	TNAME=test_etherstub_vlan

	if ! dladm create-etherstub -t $stub; then
		fail "failed to create etherstub $stub"
	fi

	create_vnic -v $vid $stub $send_vn1
	create_addr $send_ip1 $send_vn1
	create_vnic -v $vid $stub $recv_vn1
	create_addr $recv_ip1 $recv_vn1

	send_traffic $send_ip1 $recv_ip1 $recv_vn1 swlane

	delete_interface $recv_vn1
	delete_vnic $recv_vn1
	delete_interface $send_vn1
	delete_vnic $send_vn1
	if ! dladm delete-etherstub $stub; then
		fail "failed to delete etherstub $stub"
	fi
	pass
}

#
# Fail the script if the environment is not as expected.
#
function verify_env
{
	if ! which socat > /dev/null 2>&1; then
		fail "socat is required"
	fi

	if ! ipadm show-prop -co current -p hostmodel ipv4 |
			grep src-priority > /dev/null; then
		fail "ipv4 hostmodel must be 'src-priority'"
	fi
}

#
# Main script.
#
PRE_AGGR_MAC_GROUP=0
CLASSIFY=hwlane
#
# We should expect hardware classification on the primary interface
# post aggr mac groups (SmartOS OS-6719), however:
#
# 1. This isn't true for a 9000 MTU because the port SDU change causes
#    us to enter SW classify (verified on SmartOS only, not sure if
#    this holds for other distros).
#
# 2. This isn't true even without the MTU change because the primary
#    client ends up on the default group. This should be fixed in a
#    follow up.
#
PRIMARY_CLASSIFY=swlane
TNAME=""
DEBUG=0
IP_SUBNET=192.168.66

aggr=0
all=1
etherstub=0
generic=0
ixgbe=0

while getopts ":adegis:" opt
do
	case $opt in
	a)
		aggr=1
		all=0
		;;
	d)
		DEBUG=1
		;;
	e)
		etherstub=1
		all=0
		;;
	g)
		generic=1
		all=0
		;;
	i)
		ixgbe=1
		all=0
		;;
	s)
		IP_SUBNET=$OPTARG
		;;

	':')
		fail "missing argument to $OPTARG"
		;;

	'?')
		fail "unknown option '$OPTARG'"
		;;
	esac
done
shift $((OPTIND -1))

if [ $# -ne 4 ]; then
	echo "mac_test port#1 port#2 port#3 port#4" >&2
	exit 1
fi

if (($DEBUG == 1)); then
	set -x
	#
	# This is needed to trace inside functions too since they are
	# defined with the `function foo ...` syntax.
	#
	typeset -tf $(typeset +f)
fi

#
# This function didn't exist until aggr mac group support was added.
#
if ! nm /kernel/drv/amd64/aggr | \
		grep aggr_pseudo_start_rx_ring > /dev/null
then
	PRE_AGGR_MAC_GROUP=1
	CLASSIFY=swlane
	PRIMARY_CLASSIFY=swlane
fi

#
# These tests require two two-port NICs. Where PORT{1,2} is one NIC,
# and PORT{3,4} is the other. Furthermore, PORT1 should be wired to
# PORT3, and PORT2 to PORT4.
#
MT_PORT1=$1
MT_PORT2=$2
MT_PORT3=$3
MT_PORT4=$4
verify_env

IPS[0]=$IP_SUBNET.1
IPS[1]=$IP_SUBNET.2
IPS[2]=$IP_SUBNET.3
IPS[3]=$IP_SUBNET.4
IPS[4]=$IP_SUBNET.5
IPS[5]=$IP_SUBNET.6

for ip in ${IPS[@]}
do
	verify_no_ip $ip
done

#
# Generic tests should apply to any type of link.
#
if (($all == 1)) || (($generic == 1)); then
	test_generic_create_vnic $MT_PORT1
	test_generic_create_vlan $MT_PORT1
	test_generic_vnic_hw_rx $MT_PORT1 $MT_PORT3
	test_generic_vlan_hw_rx $MT_PORT1 $MT_PORT3
	test_generic_sw_to_hw $MT_PORT1 $MT_PORT3
	test_generic_promisc $MT_PORT1 $MT_PORT3
	test_generic_promisc_vlan $MT_PORT1 $MT_PORT3 7
	test_generic_vlan_all_groups $MT_PORT1 $MT_PORT3 7
	test_generic_vlan_steal_group $MT_PORT1 $MT_PORT3 7
	test_generic_vlan_shared_addr $MT_PORT1 $MT_PORT3
	test_generic_two_vlans_on_default $MT_PORT1 $MT_PORT3 7

fi


if (($all == 1)) || (($ixgbe == 1)); then
	#
	# All the ixgbe tests that follow make these assumptions. So
	# check them here, once, before running any tests.
	#
	verify_nic_type $MT_PORT1 ixgbe
	verify_nic_type $MT_PORT3 ixgbe

	test_ixgbe_many_vlans $MT_PORT1 $MT_PORT3
	test_ixgbe_vfta_repeated_vid $MT_PORT1 $MT_PORT3 7
	test_ixgbe_vlvfb_missing_default $MT_PORT1 $MT_PORT3 7
fi

if (($all == 1)) || (($etherstub == 1)); then
	test_etherstub_vlan ${IPS[0]} ${IPS[1]} 7
fi

if (($all == 1)) || (($aggr == 1)); then
	typeset senda=aggr_send1
	typeset recva=aggr_recv1

	create_aggr $senda $MT_PORT1 $MT_PORT2
	create_aggr $recva $MT_PORT3 $MT_PORT4

	test_generic_aggr_primary $senda $recva
	test_generic_aggr_primary_vlan $senda $recva 7
	test_generic_aggr_vnic $senda $recva
	test_generic_aggr_vlan $senda $recva 7
	test_generic_aggr_two_vnics $senda $recva
	test_generic_aggr_two_vlans $senda $recva 7
	test_generic_aggr_vlans_shared_addr $senda $recva 7 8
	test_generic_aggr_ref_count $senda $recva
	test_generic_aggr_vlan_ref_count $senda $recva 7
	test_generic_aggr_vnic_and_vlan $senda $recva 7

	#
	# Stealing HW groups can only happen if HW groups are implemented.
	#
	if (($PRE_AGGR_MAC_GROUP == 0)); then
		test_generic_aggr_steal_group $senda $recva
		test_generic_aggr_vlan_steal_group $senda $recva 7

	fi

	if (($all == 1)) || (($ixgbe == 1)); then
		test_aggr_ixgbe_promisc $senda $recva
		test_aggr_vlan_ixgbe_promisc $senda $recva 7
	fi

	delete_aggr $senda
	delete_aggr $recva
fi
